package llm

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	"xiaohongshu-unified/internal/config"
	"xiaohongshu-unified/internal/lunar"
	"xiaohongshu-unified/internal/traffic"
	"xiaohongshu-unified/internal/visitor"
	"xiaohongshu-unified/internal/weather"
)

// ContentRequest represents the input for content generation
type ContentRequest struct {
	Weather *weather.WeatherInfo `json:"weather"`
	Lunar   *lunar.LunarInfo     `json:"lunar"`
	Traffic *traffic.TrafficInfo `json:"traffic"`
	Visitor *visitor.VisitorInfo `json:"visitor"`
	Weibo   string               `json:"weibo,omitempty"` // Weibo content for reference
	Theme   string               `json:"theme,omitempty"` // Optional theme for the post
}

// GeneratedContent represents the generated content
type GeneratedContent struct {
	Title     string    `json:"title"`      // 小红书标题
	Content   string    `json:"content"`    // 正文内容
	Tags      []string  `json:"tags"`       // 标签
	CoverText string    `json:"cover_text"` // 封面文本（HTML格式，15字符内）
	Timestamp time.Time `json:"timestamp"`
}

// Service handles LLM content generation
type Service struct {
	cfg    *config.Config
	client *http.Client
}

// NewService creates a new LLM service
func NewService(cfg *config.Config) *Service {
	return &Service{
		cfg: cfg,
		client: &http.Client{
			Timeout: 60 * time.Second,
		},
	}
}

// DeepSeekRequest represents the request to DeepSeek API
type DeepSeekRequest struct {
	Model    string    `json:"model"`
	Messages []Message `json:"messages"`
	Stream   bool      `json:"stream"`
}

// Message represents a chat message
type Message struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

// DeepSeekResponse represents the response from DeepSeek API
type DeepSeekResponse struct {
	Choices []struct {
		Message struct {
			Content string `json:"content"`
		} `json:"message"`
	} `json:"choices"`
	Error *struct {
		Message string `json:"message"`
	} `json:"error,omitempty"`
}

// GenerateContent generates Xiaohongshu post content based on provided information
func (s *Service) GenerateContent(req *ContentRequest) (*GeneratedContent, error) {
	// Build the prompt with all available information
	prompt := s.buildPrompt(req)

	// Debug: Log the prompt being sent
	log.Printf("[DEBUG] LLM Prompt being sent to DeepSeek:")
	log.Printf("[DEBUG] Prompt length: %d characters", len(prompt))
	log.Printf("[DEBUG] Prompt content:\n%s", prompt)
	log.Printf("[DEBUG] ===========================================")

	// Prepare DeepSeek API request
	deepSeekReq := DeepSeekRequest{
		Model: s.cfg.DeepSeekLLM.Model,
		Messages: []Message{
			{
				Role:    "system",
				Content: "你是一个专业的小红书内容创作者，擅长创作有趣、实用、吸引人的生活类内容。请根据提供的信息生成高质量的小红书帖子。",
			},
			{
				Role:    "user",
				Content: prompt,
			},
		},
		Stream: false,
	}

	// Convert to JSON
	reqBody, err := json.Marshal(deepSeekReq)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Make API request
	apiURL := fmt.Sprintf("%s/chat/completions", s.cfg.DeepSeekLLM.BaseURL)
	req2, err := http.NewRequest("POST", apiURL, bytes.NewBuffer(reqBody))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req2.Header.Set("Content-Type", "application/json")
	req2.Header.Set("Authorization", fmt.Sprintf("Bearer %s", s.cfg.DeepSeekLLM.APIKey))

	resp, err := s.client.Do(req2)
	if err != nil {
		return nil, fmt.Errorf("failed to call DeepSeek API: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("DeepSeek API returned status %d", resp.StatusCode)
	}

	// Parse response
	var deepSeekResp DeepSeekResponse
	if err := json.NewDecoder(resp.Body).Decode(&deepSeekResp); err != nil {
		return nil, fmt.Errorf("failed to decode DeepSeek response: %w", err)
	}

	if deepSeekResp.Error != nil {
		return nil, fmt.Errorf("DeepSeek API error: %s", deepSeekResp.Error.Message)
	}

	if len(deepSeekResp.Choices) == 0 {
		return nil, fmt.Errorf("no content generated by DeepSeek")
	}

	// Parse the generated content
	generatedText := deepSeekResp.Choices[0].Message.Content

	// Debug: Log the response received
	log.Printf("[DEBUG] LLM Response received from DeepSeek:")
	log.Printf("[DEBUG] Response length: %d characters", len(generatedText))
	log.Printf("[DEBUG] Response content:\n%s", generatedText)
	log.Printf("[DEBUG] ===========================================")
	content, err := s.parseGeneratedContent(generatedText)
	if err != nil {
		return nil, fmt.Errorf("failed to parse generated content: %w", err)
	}

	content.Timestamp = time.Now()
	return content, nil
}

// buildPrompt builds the prompt for content generation
func (s *Service) buildPrompt(req *ContentRequest) string {
	prompt := "请根据以下信息创作一篇小红书帖子：\n\n"
	prompt += "帖子焦点是北京环球影城， 而不是北京地区旅游， 所以 1， 标题中必须含有北京环球影城； 2，tag 尽量跟环球影城相关； 3，标题需要体现日期"

	if req.Weather != nil {
		prompt += fmt.Sprintf("天气信息：\n%s\n\n", req.Weather.GetFormattedWeather())
	}

	if req.Lunar != nil {
		prompt += fmt.Sprintf("农历信息：\n%s\n\n", req.Lunar.GetFormattedLunar())
	}

	// Traffic information omitted per user request

	if req.Visitor != nil {
		prompt += fmt.Sprintf("游客信息：\n%s\n\n", req.Visitor.GetFormattedVisitor())
	}

	if req.Weibo != "" {
		prompt += "请基于以下官方微博动态，提取并总结其中的新闻和活动信息，融入到小红书内容中：\n"
		prompt += req.Weibo
		prompt += "\n请将上述官方动态中的新闻、活动、优惠等信息简洁地融入到小红书内容中，使内容更加丰富和有价值。\n\n"
	}

	if req.Theme != "" {
		prompt += fmt.Sprintf("主题要求：%s\n\n", req.Theme)
	}

	prompt += fmt.Sprintf("当前日期：%s\n\n", time.Now().Format("2006年01月02日"))
	prompt += fmt.Sprintf("推荐路线：%s\n\n", `第一天
交通方式：

地铁：乘坐地铁八通线或7号线，终点站为“环球度假区站”，步行约7分钟即可到达入口45。
自驾：通过京哈高速“田家府站”或六环路“张家湾北站”出口前往，园区提供近万个停车位15。
入园准备：

提前准备好北京环球影城指定单日门票和有效身份证件1。
入园前需关注安全指南，确保健康与安全1。
入住酒店：

推荐入住环球影城大酒店，经典西班牙复兴风格设计，位于主题公园入口附近，方便次日入园1。
酒店宾客可享受提前入园及部分景点优先游览特权（需持有效门票）1。
酒店活动：

下午带小朋友去酒店的儿童天地玩耍，体验电影主题乐园1。
次日早晨在莲花园餐厅享用自助早餐，并有机会与小黄人等角色见面1。
第二天
主题公园游玩路线：

上午：
变形金刚基地：体验“火种源争夺战”、“大黄蜂回旋机”和“变形金刚：传奇现场”1。
功夫熊猫盖世之地：参与“神龙大侠之旅”和阿宝功夫训练营1。
下午：
哈利·波特的魔法世界™：尝试“禁忌之旅™”和“鹰马飞行™”，晚上可观看城堡夜间灯光庆典1。
侏罗纪世界努布拉岛：探索“飞越侏罗纪”和奇遇迅猛龙互动1。
小黄人乐园：体验“神偷奶爸小黄人闹翻天”和萌转过山车1。
晚上：
好莱坞：欣赏“不可驯服”表演，最后在环球影城商店购买纪念品1。
结束行程：

前往北京环球城市大道，在酷巧巧克力商店或环球城市大道电影院结束完美的一天1。 
`)

	prompt += "请结合以上信息，创作一篇适合小红书平台发布的生活类帖子，内容要贴近生活，有实用价值，语言亲切自然。\n\n"

	prompt += `请按照以下JSON格式返回内容：
{
  "title": "吸引人的标题（15-20字，包含emoji, 严格控制 20 个中文字符以内）",
  "content": "正文内容（200-300字，分段，包含emoji，贴近生活，有实用价值）",
  "tags": ["相关标签1", "相关标签2", "相关标签3", "相关标签4", "相关标签5"],
  "cover_text": "封面文本（HTML格式，必须包含日期和入园人数，以及关键词“环球影城”, 限制30字符内）"
}

要求：
1. 标题要有吸引力，包含适当的emoji
2. 正文要贴近生活，有实用价值，语言亲切自然
3. 标签要准确反映内容主题
4. 整体风格要符合小红书用户喜好
5. 内容要积极正面，传递正能量
6. cover_text必须包含当前日期和入园人数以及“环球影城“，格式如："X月X日北京环球影城入园人数: <span style=\"color: #ff0000; font-weight: bold;\">XXXXX</span><br/>天气描述"，总长度不超过30个字符（不含HTML标签）
7. 标题字数不能超过 20 个中文字符（包含 emoji）`

	return prompt
}

// parseGeneratedContent parses the generated content from LLM response
func (s *Service) parseGeneratedContent(text string) (*GeneratedContent, error) {
	// Try to extract JSON from the response
	// The LLM might return additional text before/after the JSON
	start := -1
	end := -1

	// Find the JSON object boundaries
	for i, char := range text {
		if char == '{' && start == -1 {
			start = i
		}
		if char == '}' {
			end = i + 1
		}
	}

	if start == -1 || end == -1 {
		return nil, fmt.Errorf("no valid JSON found in response")
	}

	jsonStr := text[start:end]

	var content GeneratedContent
	if err := json.Unmarshal([]byte(jsonStr), &content); err != nil {
		// If JSON parsing fails, create content manually
		return s.createFallbackContent(text), nil
	}

	// Validate required fields
	if content.Title == "" {
		content.Title = "环球影城今日导览 ✨"
	}
	if content.Content == "" {
		content.Content = text // Use the raw text as content
	}
	if len(content.Tags) == 0 {
		content.Tags = []string{"生活分享", "日常", "今日推荐"}
	}

	return &content, nil
}

// createFallbackContent creates fallback content when JSON parsing fails
func (s *Service) createFallbackContent(text string) *GeneratedContent {
	currentDate := time.Now()
	defaultCoverText := fmt.Sprintf("%d月%d日入园人数: <span style=\"color: #ff0000; font-weight: bold;\">19999</span><br/>天气晴适合游玩", currentDate.Month(), currentDate.Day())

	return &GeneratedContent{
		Title:     "今日生活分享 ✨",
		Content:   text,
		Tags:      []string{"生活分享", "日常", "今日推荐", "实用信息", "生活小贴士"},
		CoverText: defaultCoverText,
	}
}

// GetFormattedContent returns the content in a format suitable for posting
func (g *GeneratedContent) GetFormattedContent() string {
	result := fmt.Sprintf("%s\n\n%s\n\n", g.Title, g.Content)

	if len(g.Tags) > 0 {
		result += "#"
		for i, tag := range g.Tags {
			if i > 0 {
				result += " #"
			}
			result += tag
		}
	}

	return result
}

